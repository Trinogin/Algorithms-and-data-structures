#ifndef DECART_TREE_H_INCLUDED
#define DECART_TREE_H_INCLUDED

// Decart Tree with implicit key

#pragma once

#include<cstdio>
#include<iostream>
#include <vector>

using std::cin;
using std::cout;
using std::endl;

using std::vector;

// Узел декартового дерева по неявному ключу. Главное отличие - мы больше не храним
// ключ в явном виде, вместо этого мы просто храним размер поддерева с корнем
// в данном узле. Доступ к элементам дерева будет осуществляться по вычисляемому
// "номеру" вершины, равному её порядковому номеру при прямом (Л-К-П) обходе.
struct Node
{
	int y;   // Как и прежде, "приоритет" вершины
	int size;  // Хранимый размер поддерева

	int value; // Хранимое значение в узле.

	Node* l;
	Node* r; // Указатели на левого и правого ребёнка
};

// Создание нового узла. Здесь мы должны инициализировать все поля узла, и при этом
// мы вполне вольны разместить вершину там, где хотим. 
Node* NewNode(int value);

// Получение размера поддерева. Функция гарантирует, что её выполнение не приведёт к ошибке
// даже при передаче ей пустого дерева.
int GetSize(Node* t);

// Пересчёт размера поддерева. Эту операцию надо выполнять каждый раз, когда с деревом происходят
// какие-либо изменения (то есть в любом split и merge) для поддержания корректности работы операций
// над деревом.
// Данная функция предполагает, что размеры потомков также являются корректными. Это обеспечивается
// в операциях split и merge за счёт их рекуррентной природы (размеры будут пересчитываться от листьев
// к корням после любого изменения)
void UpdSize(Node* t);

// Код операции слияния (merge) остаётся ровно таким же, как и для декартового дерева по явному ключу:
// для неё важен только порядок вершины (y), мы же должны гарантировать соотношение значений ключей в
// левом и правом поддеревьях, но, поскольку у нас явного ключа нет, у нас "автоматически" получится
// верное дерево
Node* Merge(Node* t_1, Node* t_2);

// Разбиение дерева на два поддерева - одно с вершинами с порядковыми номерами [0..x), другое - [x..t->sz)
// Здесь придётся делать небольшие изменения: например, поскольку ключа уже нет, надо уметь его вычислить, зная
// размеры каждого поддерева.
void Split(Node* t, int x, Node *&t1, Node *&t2);

// Добавление и удаление элементов из дерева - такие же последовательности split/merge, как и в декартовом дереве
// с той лишь разницей, что теперь мы можем указывать, например, позицию, куда надо добавить новый элемент
Node* Add(Node* t, int pos, int value);

Node* Remove(Node* t, int pos);

// Создание дерева из массива - просто слияние текущего дерева с новыми деревьями, образованными из
// элементов заданного массива.
Node* FromVector(const vector<int>& v);

// Получение k-го элемента, по сути, аналогично получению k-й порядковой статистики в
// декартовом дереве по явному ключу
int GetValue(Node* t, int pos);

// Перенести часть массива [l..r] в начало массива (как пример операции, производимой над "массивом", содержащимся в
// декартовом дереве)
Node* ToFront(Node* t, int left, int right);

// Печать всего дерева. Просто обходим наше дерево как обычное бинарное дерево поиска,
// вместо того, чтобы каждый раз пользоваться get_value.
void PrintTreap(Node* t);

void RemoveTreap(Node* t);

#endif // DECART_TREE_H_INCLUDED
